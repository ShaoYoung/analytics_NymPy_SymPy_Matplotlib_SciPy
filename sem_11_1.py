# Функция_1
# f(x) = 5x^2+10x-30
# 1. Определить корни
# 2. Найти интервалы, на которых функция возрастает
# 3. Найти интервалы, на которых функция убывает
# 4. Построить график
# 5. Вычислить вершину
# 6. Определить промежутки, на котором f > 0
# 7. Определить промежутки, на котором f < 0

# SymPy — это библиотека Python для выполнения символьных вычислений.
# В SymPy есть разные функции, которые применяются в сфере символьных вычислений, математического анализа, алгебры,
# дискретной математики, квантовой физики и так далее.
# Вот где применяется SymPy:
#     Многочлены
#     Математический анализ
#     Дискретная математика
#     Матрицы
#     Геометрия
#     Построение графиков
#     Физика
#     Статистика
#     Комбинаторика
import sympy as sym
# from sympy import *

# Matplotlib - библиотека для создания научной графики.
# Она позволяет на лету создавать простейшие графики всего в несколько строк кода и в тоже время она предоставляет
# полный контроль над всеми элементами графиков, что незаменимо при подготовке публикаций и презентаций.
# https://pyprog.pro/mpl/mpl_short_guide.html
import matplotlib.pyplot as plt

# В Python переменные необходимо принудительно объявить символьными и сделать это можно несколькими путями.
# Самым простым будет использование функций symbols() или var().
# Первая функция возвращает ссылку на символьный объект в виде какой-либо переменной. Вторая, без присваивания создает символьную переменную.
# С символами можно производить преобразования с использованием некоторых операторов языка Python. А именно, арифметических (+, -`, ``*, **) и логических (&, |, ~) .
x = sym.symbols('x')
func = 5 * x ** 2 + 10 * x - 30
print(f'Функция: {func}')
# Для любого символьного объекта существует метод evalf(...)(evaluate float), который возвращает его десятичное представление:
# print(sym.pi.evalf())
# С округлением
# print(sym.pi.evalf(30))
# В sympy становится доступен символ бесконечности – oo (две буквы „o‟), с которым тоже можно выполнять определенные операции
# print(sym.oo)
# print(1/sym.oo)

# найти корни
print("1. Определить корни")

# solve алгебраически решает уравнения и системы уравнений.
y = sym.solve(func)
print(y)
x1 = round(float(y[0]), 2)
x2 = round(float(y[1]), 2)
print(x1, x2)

print("2. Найти интервалы, на которых функция возрастает")
# diff дифференцировать функцию по символам. Возврат дифференцирования математического выражения (дифференциал, производная)
fd = sym.diff(func)
# дифференциал функции
print(f'Дифференциал функции: {fd}')
print(sym.solve(0 < fd))

print("3. Найти интервалы, на которых функция убывает")
print(sym.solve(fd < 0))

# SymPy использует библиотеку matplotlib в качестве бэкенда для рендеринга двухмерных и трехмерных графиков математических функций.
# Команда %matplotlib inline указывает, что график необходимо построить все в той же оболочке Jupyter,
# но теперь он выводится как обычная картинка.
# Данный способ удобен тем, что позволяет проводить очень много экспериментов в рамках одного окна (точнее web-страницы).
print("4. Построить график")
# список значений функции
list_y = []
# начало интервала по x
start = -10
# конец интервала по x
finish = 10
# заполнение списка значений функции (можно через List comprehension)
for x in range(start, finish + 1):
    # x = i
    y = 5 * x ** 2 + 10 * x - 30
    list_y.append(y)
# print(list_y)
# Метод plt.plot(), в простейшем случае, принимает один аргумент - последовательность чисел,
# которая соответствует оси ординат (y), ось абсцис (x) строится автоматически от 0 до n, где n - это длина массива ординат.
# можно передать два списка - ось x и ось y
# метод plt.plot() занимается прорисовкой линий графика
# рисует ось ординат (x)
# plt.plot(range(start, finish + 1), [0 for i in range(start, finish + 1)])
# рисуем горизонтальную линию
plt.hlines(0, start, finish)
plt.plot(range(start, finish + 1), list_y)
# plt.grid() - сетка на графике
plt.grid()
plt.arrow(-1, 30, 0, -55, width=0.1, head_length=10)
plt.title('simple graph')
# Формулы могут помещаться как в заголовки, так и внутрь самой области Axes с помощью метода Axes.text().
# Matplotlib имеет внутренний движок и все необходимое для отображения формул, так что формулы доступны прямо "из коробки".
# Математический текст передается в виде строки, начало и конец которого обозначаются символом $.
# При этом мы должны использовать необработанные строки, т.е. ставить символ r перед открывающей строку кавычкой -
# это необходимо для того что бы символы \ в математическом тексте не интерпретировались как часть специальных строковых символов, таких как \n.
# plt.title(r'$y(x)=5 * x ** 2 + 10 * x - 30$')
plt.xlabel('x')
plt.ylabel('y(x)=5 * x ** 2 + 10 * x - 30')
# plt.show() отображение графика.
plt.show()

# создаём figure и axes
# Figure - это контейнер самого верхнего уровня, та область на которой все нарисовано.
# Таких областей может быть несколько, каждая из которых может содержать несколько контейнеров Axes.
fig_1 = plt.figure()
fig_1.set_facecolor('gray')
# Axes - это та область на которой чаще всего и отражаются графики (данные в виде графиков), а так же все вспомогательные атрибуты
# (линии сетки, метки, указатели и т.д.). Часто, установка этой области сопровождается с вызовом subplot, который и помещает Axes на регулярную сетку.
# Поэтому, так же часто Axes и Subplot можно считать синонимами.
# метод add_subplot() разбивает Figure на указанное количество строк и столбцов.
# После такого разбиения Figure можно представить как таблицу (или координатную сетку). Затем область Axes помещается в указанную ячейку.
# Для всего этого add_subplot() необходимо всего три числа, которые мы и передаем ему в качестве параметров:
# первое - количество строк;
# второе - количество столбцов
# третье - индекс ячейки. Индексирование полученных ячеек начинается с левого верхнего угла, выполняется построчно слева-направо и заканчивается в правом нижнем углу.
ax_1 = fig_1.add_subplot(3, 1, 1)
ax_2 = fig_1.add_subplot(2, 1, 2)

# график множества точек (точки не соединяются линиями) plt.scatter
ax_1.plot(range(start, finish + 1), [0 for i in range(start, finish + 1)], linewidth=1)
ax_1.scatter(range(start, finish + 1), list_y, color='green', marker='*')
ax_1.set(title='scatter')
# установка цвета
# graph.set_color('green')
# plt.show()

# гистограммы plt.bar
ax_2.plot(range(start, finish + 1), [0 for i in range(start, finish + 1)])
ax_2.bar(range(start, finish + 1), list_y)
# несколько наборов данных (width - ширина столбца гистограммы
ax_2.bar(range(start, finish + 1), list(map(lambda x: x / 2, list_y)), width=0.2)
ax_2.set(title='bar')
# сохранение рисунка графика - savefig объекта Figure, необходимый параметр - строка с именем будущего файла:
fig_1.savefig('graph.jpg', dpi=300)
fig_1.savefig('graph.pdf', dpi=1200)
fig_1.savefig('graph.svg', dpi=2400)

plt.show()

fig_2 = plt.figure()
ax_3 = fig_2.add_subplot(2, 1, 1)
ax_4 = fig_2.add_subplot(2, 1, 2)

# круговые диаграммы
ax_3.pie([30, 25, 50])
ax_3.set(title='pie')
# plt.show()

# ящик с усами (применяется в статистике)
ax_4.boxplot([[1, 5, 7, 4, 6, 10, 15],
              [-2, 5, 7, 4, 6, 10, 15],
              [-4, 5, 7, 4, 6, 10]])
ax_4.set(title='boxplot')
plt.show()

# СОХРАНЕНИЕ ГРАФИКА


print("5. Вычислить вершину. В общем случае их может быть много")
# ищем точки, в которых дифференциал функции равен нулю (т.е. функция не прирастает и не уменьшается)
corni = sym.solve(fd)
print(f'Корни дифференциала (экстремумы) функции {corni}')
top = corni[0]
x = top
print(f'Дифференциал функции равен нулю при x = {corni}')
y = 5 * x ** 2 + 10 * x - 30
print(f'Экстремум {top}, при этом значение функции {y}')

print("6. Определить промежутки, на котором f > 0")
print(sym.solve(0 < func))

print("7. Определить промежутки, на котором f < 0")
print(sym.solve(func < 0))
